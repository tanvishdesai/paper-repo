{
    "chapter": "Theory of Computation",
    "types": [
      {
        "numerical_type_id": "TOC-TOC-TYPE-01",
        "numerical_type_name": "Grammar & Automata Interpretation",
        "numerical_type_description": "These questions require analyzing a given formal definition, such as a context-free grammar, a finite automaton, or a push-down automaton. The task is to determine the specific language it generates or accepts, or to trace its behavior on a given input string. This involves understanding the rules of the formal system and deriving the set of strings that conform to them.",
        "question_ids": [
          "2009_CS_Q.12",
          "2009_CS_Q.41",
          "2012_CS_Q.12",
          "2012_CS_Q.25",
          "2012_CS_Q.46",
          "2014_CS_16",
          "2015_CS_35",
          "2015_CS_Q. 51",
          "2016_CS_Q.16",
          "2016_CS_Q.46",
          "2017_CS_10",
          "2017_CS_34",
          "2023_CS_Q.19",
          "2023_CS_Q.39",
          "2023_CS_Q.40",
          "2024_Computer Science and Information Technology Set 2 (CS2)_Q.52",
          "2025_CS1_Q.19",
          "2025_CS1_Q.50"
        ]
      },
      {
        "numerical_type_id": "TOC-TOC-TYPE-02",
        "numerical_type_name": "Regex & DFA Construction",
        "numerical_type_description": "This question type focuses on the design and optimization of representations for regular languages. Tasks include constructing a regular expression that describes a given language, determining the minimum number of states required for a DFA, or converting between equivalent NFAs, DFAs, and regular expressions. These problems test practical skills in language representation.",
        "question_ids": [
          "2009_CS_Q.15",
          "2010_CS_39",
          "2010_CS_41",
          "2011_CS_Q.42",
          "2011_CS_Q.45",
          "2013_CS_Q.8",
          "2014_CS_36",
          "2014_CS SET-3_Q.15",
          "2015_CS_18",
          "2015_CS_53",
          "2015_CS_Q. 52",
          "2016_CS_Q.16",
          "2016_CS_Q.18",
          "2017_CS_22",
          "2018_CS_52",
          "2020_CS_51",
          "2020_CS_7",
          "2021_CS_CS Q.17",
          "2021_CS_CS Q.47",
          "2021_CS_CS Q.9",
          "2022_CS_Q.12",
          "2023_CS_Q.14",
          "2023_CS_Q.63",
          "2024_Computer Science and Information Technology Set 2 (CS2)_Q.22",
          "2024_Computer Science and Information Technology Set 2 (CS2)_Q.41",
          "2024_Computer Science and Information Technology Set 2 (CS2)_Q.62",
          "2025_CS1_Q.28",
          "2025_CS2_Q.60"
        ]
      },
      {
        "numerical_type_id": "TOC-TOC-TYPE-03",
        "numerical_type_name": "Language Classification",
        "numerical_type_description": "These questions involve classifying a given language within the Chomsky hierarchy (i.e., regular, context-free, recursive). The language is typically defined using set-builder notation. Solving these problems often requires applying theoretical tools like the Pumping Lemma or identifying structural properties of the language that correspond to a specific automaton model.",
        "question_ids": [
          "2009_CS_Q.40",
          "2010_CS_40",
          "2011_CS_Q.26",
          "2014_CS_15",
          "2014_CS-2_15",
          "2014_CS-2_36",
          "2015_CS_32",
          "2015_CS_51",
          "2016_CS_Q.17",
          "2016_CS_Q.43",
          "2017_CS_37",
          "2017_CS_38",
          "2018_CS_35",
          "2020_CS_10",
          "2020_CS_32",
          "2021_CS_CS Q.41",
          "2022_CS_Q.47",
          "2022_CS_Q.48",
          "2025_CS1_Q.44",
          "2025_CS1_Q.45",
          "2025_CS2_Q.24",
          "2025_CS2_Q.52"
        ]
      },
      {
        "numerical_type_id": "TOC-TOC-TYPE-04",
        "numerical_type_name": "Decidability & Closure Properties",
        "numerical_type_description": "This type includes theoretical questions about the fundamental properties of language families. It covers closure properties, which concern whether a language family is closed under operations like union, intersection, and complement. It also covers decidability, asking whether certain problems about languages or machines (e.g., emptiness, equivalence) can be solved by an algorithm.",
        "question_ids": [
          "2009_CS_Q.14",
          "2010_CS_17",
          "2011_CS_Q.24",
          "2012_CS_Q.24",
          "2013_CS_Q.17",
          "2014_CS_35",
          "2014_CS-2_16",
          "2014_CS-2_35",
          "2015_CS_21",
          "2015_CS_53",
          "2015_CS_Q. 3",
          "2016_CS_Q.17",
          "2016_CS_Q.18",
          "2016_CS_Q.42",
          "2016_CS_Q.44",
          "2017_CS_39",
          "2017_CS_4",
          "2018_CS_36",
          "2020_CS_26",
          "2020_CS_8",
          "2021_CS_CS Q.12",
          "2021_CS_CS-Q.1",
          "2022_CS_Q.23",
          "2022_CS_Q.46",
          "2023_CS_Q.24",
          "2025_CS2_Q.25",
          "2025_CS2_Q.30"
        ]
      },
      {
        "numerical_type_id": "TOC-TOC-TYPE-05",
        "numerical_type_name": "Formal Language Model Comparison",
        "numerical_type_description": "These questions focus on comparing the expressive power and characteristics of different computational models. This includes understanding the relationships and equivalences between models like DFA vs NFA, DPDA vs NPDA, and different types of Turing machines. It also covers questions on the properties of language hierarchies and complexity classes like P and NP.",
        "question_ids": [
          "2009_CS_Q.16",
          "2011_CS_Q.8",
          "2012_CS_Q.4",
          "2013_CS_Q.18",
          "2014_CS_38",
          "2015_CS_2",
          "2018_CS_6",
          "2018_CS_7",
          "2021_CS_CS Q.36"
        ]
      }
    ]
  }