Question_Number,Question_Text,Question_Images,Option_A,Option_A_Images,Option_B,Option_B_Images,Option_C,Option_C_Images,Option_D,Option_D_Images,Correct_Answer,Question_Type,Explanation,Explanation_Images
1,"Suppose we want to synchronize two concurrent processes P and Q using binary semaphores S and T. The code for the processes P and Q is shown below. Process P: while (1) { W: print '0'; print '0'; X: } Process Q: while (1) { Y: print '1'; print '1'; Z: } Synchronization statements can be inserted only at points W, X, Y and Z  Which of the following will ensure that the output string never contains a substring of the form 01^n0 or 10^n1 where n is odd?",,"P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S and T initially 1",,"P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S and T initially 1",,"P(S) at W, V(S) at X, P(S) at Y, V(S) at Z, S initially 1",,"V(S) at W, V(T) at X, P(S) at Y, P(T) at Z, S and T initially 1",,C,MCQ,"P(S) means wait on semaphore ’S’ and V(S) means signal on semaphore ‘S’. The definition of these functions are : Wait(S) { while (i <= 0) ; S-- ; } Signal(S) { S++ ; } Initially S = 1 and T = 0 to support mutual exclusion in process ‘P’ and ‘Q’. Since, S = 1 , process ‘P’ will be executed and function Wait(S) will decrement the value of ‘S’. So,  S = 0 now. Simultaneously, in process ‘Q’ , T = 0 . Therefore, in process ‘Q’  control will be stuck in while loop till the time process ‘P’ prints ‘00’ and increments the value of ‘T’ by calling function V(T). While the control is in process ‘Q’,  S = 0 and process ‘P’ will be stuck in while loop. Process ‘P’ will not execute till the time process ‘Q’ prints ‘11’ and makes S = 1 by calling function V(S). Thus, process 'P' and 'Q' will keep on repeating to give the output ‘00110011 …… ‘ .  Watch GeeksforGeeks Video Explanation : Please comment below if you find anything wrong in the above post.",
2,"Suppose we want to synchronize two concurrent processes P and Q using binary semaphores S and T. The code for the processes P and Q is shown below. Process P: while (1) { W: print '0'; print '0'; X: } Process Q: while (1) { Y: print '1'; print '1'; Z: } Synchronization statements can be inserted only at points W, X, Y and Z. Which of the following will always lead to an output starting with '001100110011' ?",,"P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S and T initially 1",,"P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S initially 1, and T initially 0",,"P(S) at W, V(T) at X, P(T) at Y, V(S) at Z, S and T initially 1",,"P(S) at W, V(S) at X, P(T) at Y, V(T) at Z, S initially 1, and T initially 0",,B,MCQ,"P(S) means wait on semaphore ‘S’ and V(S) means signal on semaphore ‘S’. Initially, we assume S = 1 and T = 0 to support mutual exclusion in process P and Q.  Since S = 1, only process P will be executed and wait(S) will decrement the value of S. Therefore, S = 0.  At the same instant, in process Q, value of T = 0. Therefore, in process Q, control will be stuck in while loop till the time process P prints 00 and increments the value of T by calling the function V(T).  While the control is in process Q, semaphore S = 0 and process P would be stuck in while loop and would not execute till the time process Q prints 11 and makes the value of S = 1 by calling the function V(S). This whole process will repeat to give the output 00 11 00 11 …  . Thus, B is the correct choice.  Watch GeeksforGeeks Video Explanation :",
3,A 2 km long broadcast LAN has 10 7 bps bandwidth and uses CSMA/CD. The signal travels along the wire at 2 × 10 8 m/s. What is the minimum packet size that can be used on this network?,,50 bytes,,100 bytes,,200 bytes,,None of these,,D,MCQ,"In CSMA/CD, the transmitting node is listening for collisions while it transmits it's frame. Once it has finished transmitting the final bit without hearing a collision, it assumes that the transmission was successful. In this worst-case collision scenario, the time that it takes for a Node to detect that its frame has been collided with is twice the propagation delay. Hence to confirm that the collision has not occurred the condition for the minimum size of the packet is: RTT = Transmission Time Transmission Time = Length of packet / Bandwidth RTT = 2 (d/v) = 2(2000/2×10^8) Therefore to find minimum size of the packet, RTT = Length of packet / Bandwidth Length of packet = RTT x Bandwidth = 2(2000/2×10^8) x 10^7 = 200bits = 25bytes Therefore, minimum size of the packet = 25bytes",
4,Host A is sending data to host B over a full duplex link. A and B are using the sliding window protocol for flow control. The send and receive window sizes are 5 packets each. Data packets (sent only from A to B) are all 1000 bytes long and the transmission time for such a packet is 50 µs. Acknowledgement packets (sent only from B to A) are very small and require negligible transmission time. The propagation delay over the link is 200 us. What is the maximum achievable throughput in this communication?,https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/f7f71514e1b7a006-H22Fp7Fh0asFBSSsRYhLHN8cKiClOE.png,A,,B,,C,,D,,B,MCQ,"Network throughput, ≈ Window size / roundtrip time Roundtrip time, = 2 × Packet delivery time + processing delay = Transmission delay + 2 * propagation delay = 50 microsec + 2 * 200 microsec = 450 microsec Now, Throughput = ((5*1000*bytes)/450microsec) = 11.1111 * 10 6 bytes per second So, option (B) is correct.",
5,"Consider the following three claims 1. (n + k) m = Θ(n m ), where k and m are constants 2. 2 n + 1 = O(2 n ) 3. 2 2n + 1 = O(2 n ) Which of these claims are correct ?",,1 and 2,,1 and 3,,2 and 3,,"1, 2, and 3",,A,MCQ,(n + k) m and Θ(n m ) are asymptotically same as theta notation can always be written by taking the leading order term in a polynomial expression.   2 n + 1 and O(2 n ) are also asymptotically same as 2 n + 1 can be written as 2 * 2 n and constant multiplication/addition doesn't matter in theta notation. 2 2n + 1 and O(2 n ) are not same as constant is in power.,
6,"In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. What would be the worst-case time complexity of the Insertion Sort algorithm, if the inputs are restricted to permutations of 1.....n with at most n inversions?",,Θ (n 2 ),,Θ (n*log(n)),,Θ (n 1.5 ),,Θ (n),,D,MCQ,"Insertion sort runs in Θ(n + f(n)) time, where f(n) denotes the number of inversions initially present in the array being sorted.",
7,"Consider the C program shown below. C #include <stdio.h> #define print(x) printf(""%d "", x) int x ; void Q ( int z ) { z += x ; print ( z ); } void P ( int * y ) { int x = * y + 2 ; Q ( x ); * y = x - 1 ; print ( x ); } main ( void ) { x = 5 ; P ( & x ); print ( x ); } The output of this program is",,12 7 6,,22 12 11,,14 6 6,,7 6 6,,A,MCQ,"x is global so first x becomes 5 by the first line in main(). Then main() calls P() with address of x. // in main(void) x = 5 // Change global x to 5 P(&x) P() has a local variable named 'x' that hides global variable. P() then calls Q() by passing value of local 'x'. // In P(int *y) int x = *y + 2; // Local x = 7 Q(x); In Q(int z), z uses x which is global // In Q(int z) z += x; // z becomes 5 + 7 printz(); // prints 12 After end of Q(), control comes back to P(). In P(), *y (y is address of global x) is changed to x - 1 (x is local to P()). // Back in P() *y = x - 1; // *y = 7-1 print(x); // Prints 7 After end of Q(), control comes back to main(). In main(), global x is printed. // Back in main() print(x); // prints 6 (updated in P() //           by *y = x - 1 )",
8,"In a system with 32 bit virtual addresses and 1 KB page size, use of one-level page tables for virtual to physical address translation is not practical because of",,the large amount of internal fragmentation,,the large amount of external fragmentation,,the large memory overhead in maintaining page tables,,the large computation overhead in the translation process,,C,MCQ,See question 4 of http://www.geeksforgeeks.org/operating-systems-set-4/,
9,"Which of the following is NOT an advantage of using shared, dynamically linked libraries as opposed to using statically linked libraries ?",,Smaller sizes of executable files,,Lesser overall page fault rate in the system,,Faster program startup,,Existing programs need not be re-linked to take advantage of newer versions of libraries,,C,MCQ,"Refer Static and Dynamic Libraries In Non-Shared (static) libraries, since library code is connected at compile time, the final executable has no dependencies on the library at run time i.e. no additional run-time loading costs, it means that you don’t need to carry along a copy of the library that is being used and you have everything under your control and there is no dependency.",
10,"A processor uses 2-level page tables for virtual to physical address translation. Page tables for both levels are stored in the main memory. Virtual and physical addresses are both 32 bits wide. The memory is byte addressable. For virtual to physical address translation, the 10 most significant bits of the virtual address are used as index into the first level page table while the next 10 bits are used as index into the second level page table. The 12 least significant bits of the virtual address are used as offset within the page. Assume that the page table entries in both levels of page tables are 4 bytes wide. Further, the processor has a translation look-aside buffer (TLB), with a hit rate of 96%. The TLB caches recently used virtual page numbers and the corresponding physical page numbers. The processor also has a physically addressed cache with a hit rate of 90%. Main memory access time is 10 ns, cache access time is 1 ns, and TLB access time is also 1 ns. 	 Suppose a process has only the following pages in its virtual address space: two contiguous code pages starting at virtual address 0x00000000, two contiguous data pages starting at virtual address 0×00400000, and a stack page starting at virtual address 0×FFFFF000. The amount of memory required for storing the page tables of this process is:",,8 KB,,12 KB,,16 KB,,20 KB,,C,MCQ,"Breakup of given addresses into bit form:- 32bits are broken up as 10bits (L2) | 10bits (L1) | 12bits (offset) first code page: 0x00000000 = 0000 0000 00 | 00 0000 0000 | 0000 0000 0000 so next code page will start from 0x00001000 = 0000 0000 00 | 00 0000 0001 | 0000 0000 0000 first data page: 0x00400000 = 0000 0000 01 | 00 0000 0000 | 0000 0000 0000 so next data page will start from 0x00401000 = 0000 0000 01 | 00 0000 0001 | 0000 0000 0000 only one stack page: 0xFFFFF000 = 1111 1111 11 | 11 1111 1111 | 0000 0000 0000 Now, for second level page table, we will just require 1 Page which will contain following 3 distinct entries i.e. 0000 0000 00, 0000 0000 01, 1111 1111 11. Now, for each of these distinct entries, we will have 1-1 page in Level-1. Hence, we will have in total 4 pages and page size = 2^12 = 4KB. Therefore, Memory required to store page table = 4*4KB = 16KB.",
11,"A processor uses 2-level page tables for virtual to physical address translation. Page tables for both levels are stored in the main memory. Virtual and physical addresses are both 32 bits wide. The memory is byte addressable. For virtual to physical address translation, the 10 most significant bits of the virtual address are used as index into the first level page table while the next 10 bits are used as index into the second level page table. The 12 least significant bits of the virtual address are used as offset within the page. Assume that the page table entries in both levels of page tables are 4 bytes wide. Further, the processor has a translation look-aside buffer (TLB), with a hit rate of 96%. The TLB caches recently used virtual page numbers and the corresponding physical page numbers. The processor also has a physically addressed cache with a hit rate of 90%. Main memory access time is 10 ns, cache access time is 1 ns, and TLB access time is also 1 ns.  	 Assuming that no page faults occur, the average time taken to access a virtual address is approximately (to the nearest 0.5 ns)",,1.5 ns,,2 ns,,3 ns,,4 ns,,D,MCQ,"The possibilities are TLB Hit*Cache Hit + TLB Hit*Cache Miss + TLB Miss*Cache Hit + TLB Miss*Cache Miss = 0.96*0.9*2 + 0.96*0.1*12 + 0.04*0.9*22 + 0,04*0.1*32 = 3.8 ≈ 4 Why 22 and 32? 22 is because when TLB miss occurs it takes 1ns and the for the physical address it has to go through two level page tables which are in main memory and takes 2 memory access and the that page is found in cache taking 1 ns which gives a total of 22",
12,Using a larger block size in a fixed block size file system leads to :,,better disk throughput but poorer disk space utilization,,better disk throughput and better disk space utilization,,poorer disk throughput but better disk space utilization,,poorer disk throughput and poorer disk space utilization,,A,MCQ,"Using larger block size makes disk utilization poorer as more space would be wasted for small data in a block.  It may make throughput better as the number of blocks would decrease. A larger block size guarantees that more data from a single file can be written or read at a time into a single block without having to move the disk ́s head to another spot on the disk. The less time you spend moving your heads across the disk, the more continuous reads/writes per second. The smaller the block size, the more frequent it is required to move before a read/write can occur. Larger block size means less number of blocks to fetch and hence better throughput. But larger block size also means space is wasted when only small size is required and hence poor utilization.",
13,The cube root of a natural number n is defined as the largest natural number m such that m 3 ≤ n. The complexity of computing the cube root of n (n is represented in binary notation) is:,,O(n) but not O(n 0.5 ),,O(n 0.5 ) but not O((log n) k ) for any constant k > 0,,"O((log n) k ) for some constant k > 0, but not O ((log log n) m ) for any constant m > 0",,"O((log log n) m ) for some constant k > 0.5, but not O((log log n) 0.5 )",,C,MCQ,,
14,"In the following C program fragment, j, k n and TwoLog_n are integer variables, and A is an array of integers. The variable n is initialized to an integer ≥ 3, and TwoLog_n is initialized to the value of 2*⌈log2(n)⌉ C for ( k = 3 ; k < = n ; k ++ ) A [ k ] = 0 ; for ( k = 2 ; k < = TwoLog_n ; k ++ ) for ( j = k + 1 ; j < = n ; j ++ ) A [ j ] = A [ j ] || ( j % k ); for ( j = 3 ; j < = n ; j ++ ) if ( ! A [ j ]) printf ( ""%d"" , j ); The set of numbers printed by this program fragment is",,"{m | m ≤ n, (∃ i) [m = i!]} Here i! mean factorial of i",,"{m | m ≤ n, (∃ i) [m = i 2 ]}",,"{m | m ≤ n, m is prime}",,Last print never executes,,D,MCQ,Option (D) is correct because if take n=4 then TwoLog_n value 4. first loop initially A[3]=A[4]=0; then two loop k = 2 to 4 and j = 3 to 4 if k=2 j=3  A[3] = A[3] || (3%2) = 0 || 1 A[3] = 1 j=4  A[4] = A[4] || (4%2) = 0 || 0 A[4] = 0 K=3 j=4  A[4] = A[4] || (4%3) = 0 || 1 A[4] = 1 K=4 J=5 condition false means terminate A[3] = A[4] = 1 Means last print loop never execute.,
15,"In a permutation a1.....an of n distinct integers, an inversion is a pair (ai, aj) such that i < j and ai > aj. If all permutations are equally likely, what is the expected number of inversions in a randomly chosen permutation of 1.....n ?",,n(n - 1)/2,,n(n - 1)/4,,n(n + 1)/4,,2n[log2 n],,B,MCQ,"There are n(n-1)/2 pairs such that i < j. For a pair (ai, aj), probability of being inversion is 1/2. Therefore expected value of inversions = 1/2 * (n(n-1)/2) = n(n-1)/4",
16,"The following are the starting and ending times of activities A, B, C, D, E, F, G and H respectively in chronological order: ""a s b s c s a e d s c e e s f s b e d e g s e e f e h s g e h e ""  Here, x s denotes the starting time and x e denotes the ending time of activity X. W need to schedule the activities in a set of rooms available to us. An activity can be scheduled in a room only if the room is reserved for the activity for its entire duration. What is the minimum number of rooms required ?",,3,,4,,5,,6,,B,MCQ,Room1 - As Room2 - Bs Room3 - As now A ends (Ae) and now Room3 is free Room3-Ds now A ends (Ae) and Room1 is free Room1-Es Room4-Fs now B ends Room2 is free now D ends Room3 is free Room2-Gs now E ends Room1 free now F ends Room4 free Room1-Hs now G and H ends. Totally used 4 rooms,
17,"A data structure is required for storing a set of integers such that each of the following operations can be done in (log n) time, where n is the number of elements in the set. o	Delection of the smallest element o	Insertion of an element if it is not already present in the set Which of the following data structures can be used for this purpose?",,A heap can be used but not a balanced binary search tree,,A balanced binary search tree can be used but not a heap,,Both balanced binary search tree and heap can be used,,Neither balanced binary search tree nor heap can be used,,B,MCQ,"First we’ll discuss about heap and balanced bst and its time complexities for basic operations like insertion, deletion, find. Heap:- Let us consider it as min heap 1) Insertion: O(logn) 2) Delete Min: O(logn) (Just replace root with INT_MAX and heapify) 3) Find: O(n) Balanced BST:- 1) Insertion: O(logn) 2) Delete Min: O(logn) 3) Find: O(logn) Statement 1: 1) Deletion of smallest element can be done in O(logn) in both data structures Statement 2: 1) Insertion of an element if it is not already present in the set In heap, we can perform this operation in O(n) because we have to perform linear search here, where as in BST we can perform this in O(logn)",
18,"Ram and Shyam have been asked to show that a certain problem Π is NP-complete. Ram shows a polynomial time reduction from the 3-SAT problem to Π, and Shyam shows a polynomial time reduction from Π to 3-SAT. Which of the following can be inferred from these reductions ?",,Π is NP-hard but not NP-complete,,"Π is in NP, but is not NP-complete",,Π is NP-complete,,"Π is neither NP-hard, nor in NP",,C,MCQ,"Since polynomial time reduction from the 3-SAT problem to Π is possible, it is NP hard.  Since polynomial time reduction from Π  to 3-SAT is possible, it is NP-Complete.",
19,Consider the following recurrence relation The value of T(m 2 ) for m ≥ 1 is,https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/b4f5db11548691d4-O5JxeKhW9fRcFM1toU2OI8s8pqjYcZ.png,(m/6) (21m - 39) + 4,,(m/6) (4m 2 - 3m + 5),,(m/2) (m 2.5 - 11m + 20) - 5,,(m/6) (5m 3 - 34m 2 + 137m - 104) + (5/6),,B,MCQ,"One easy way to solve this is to try putting different values of m. For example, we know T(1) = 1. If we put m = 1, only A and B satisfy the result. m = 2 T(2) = T(1) + 1 = 2 T(3) = T(2) + 1 = 3 T(4) = T(3) + 2 = 5 Both A & B produce 5 m = 3 T(9) = T(4) + 2*5 + 1 = 5 + 10 + 1 = 16 Both A & B produce 16 m = 4 T(16) = T(9) + 3*7 + 1 = 16 + 21 + 1 = 38 Only B produces 38, A produces 34 which doesn't match",
20,"Let G = (V, E) be an undirected graph with a subgraph G1 = (V1, El). Weights are assigned to edges of G as follows : A single-source shortest path algorithm is executed on the weighted graph (V, E, w) with an arbitrary vertex ν1 of V1 as the source. Which of the following can always be inferred from the path costs computed?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/22c0d9dabf2fb38b-Vuf0vRfhlThyOwLNnwCQmGHPNgx5Lz.png,The number of edges in the shortest paths from ν1 to all vertices of G,,G1 is connected,,V1 forms a clique in G,,G1 is a tree,,B,MCQ,"When shortest path shortest path from v1 (one of the vertices in V1) is computed.  G1 is connected if the distance from v1 to any other vertex in V1 is greater than 0, otherwise G1 is disconnected.",
21,"Let G (V, E) be a directed graph with n vertices. A path from v i to v j in G is sequence of vertices (v i , v i+1 , ......., v j ) such that (vk, v k+1 ) ∈ E for all k in i through j - 1. A simple path is a path in which no vertex appears more than once. Let A be an n x n array initialized as follow Consider the following algorithm. for i = 1 to n for j = 1 to n for k = 1 to n A [j , k] = max (A[j, k] (A[j, i] + A [i, k]); Which of the following statements is necessarily true for all j and k after terminal of the above algorithm ?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/3badb9b072666c0c-q2g9zK0agPLOfmUNoOp8Q4jwE0tZVa.png,"A[j, k] ≤ n",,"If A[j, k] ≥ n - 1, then G has a Hamiltonian cycle",,"If there exists a path from j to k, A[j, k] contains the longest path lens from j to k",,"If there exists a path from j to k, every simple path from j to k contain most A[j, k] edges",,D,MCQ,"In the original input matrix,  A[j , k] is 1 if there is an edge from j to k, else 0. Below expression is important to note: A[j , k] = max(A[j, k] (A[j, i] + A [i, k]); This expression puts the count of maximum edges on a path from j to k.  In this expression, we consider every vertex k that can become an intermediate vertex and can give longer path.",
22,What is the weight of a minimum spanning tree of the following graph? Figure,https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/f69ce1844b775fcf-Y3qygq21CMke9n0ZrH7Ef9CdDE51Gb.webp,29,,31,,38,,41,,D,MCQ,"Correct Answer: (d) 41 This is the total weight of the Minimum Spanning Tree (MST) for the given graph, likely computed using Kruskal’s or Prim’s Algorithm .",
23,"Consider the following functional dependencies in a database: Data_of_Birth → Age Age → Eligibility Name → Roll_number Roll_number → Name Course_number → Course_name Course_number → Instructor (Roll_number, Course_number) → Grade The relation (Roll_number, Name, Date_of_birth, Age) is:",,In second normal form but not in third normal form,,In third normal form but not in BCNF,,In BCNF,,None of the above,,D,MCQ,The given table is not in 2NF as age is dependent on date of birth.,
24,"Consider the set of relations shown below and the SQL query that follows. Students: (Roll_number, Name, Date_of_birth) Courses: (Course number, Course_name, Instructor) Grades: (Roll_number, Course_number, Grade) select distinct Name from Students, Courses, Grades where Students. Roll_number = Grades.Roll_number and Courses.Instructor = Korth and Courses.Course_number = Grades.Course_number and Grades.grade = A Which of the following sets is computed by the above query?",,Names of students who have got an A grade in all courses taught by Korth,,Names of students who have got an A grade in all courses,,Names of students who have got an A grade in at least one of the courses taught by Korth,,None of the above,,C,MCQ,"The query gives the name of all the students who have scored ""A"" grade in any of the courses that are taught by Korth. So, C is the correct choice.",
25,"Consider the following SQL query select distinct al, a2,........., an from r1, r2,........, rm where P For an arbitrary predicate P, this query is equivalent to which of the following relational algebra expressions ? A: [Tex]\prod_{a_{1},a_{2},...a_{n}}\sigma_{\rho} (r_{1}\times r_{2}\times r_{3}....\times r_{m})[/Tex] B: [Tex]\prod_{a_{1},a_{2},...a_{n}}\sigma_{\rho} (r_{1}\bowtie r_{2}\bowtie r_{3}....\bowtie r_{m})[/Tex] C: [Tex]prod_{a_{1},a_{2},...a_{n}}\sigma_{\rho} (r_{1}\cup r_{2}\cup r_{3}....\cup r_{m}[/Tex] D: [Tex]prod_{a_{1},a_{2},...a_{n}}\sigma_{\rho} (r_{1}\cap r_{2}\cap r_{3}....\cap r_{m})[/Tex]",,A,,B,,C,,D,,A,MCQ,"Cross product (x) combines the tuples of one relation with all the tuples of the other relation. Thus, tuples of relation r1, r2 …. rn are combined. Select operator [Tex]\sigma[/Tex] is used to select resultant tuples. Projection operator [Tex]\prod_{a_{1},a_{2},...a_{n}}[/Tex] is used to select a subset of  attributes from the resultant tuples by specifying the names of the attributes. So attributes a1, a2, an are projected from the resultant tuples. Thus, option (A) is correct.",
26,"Consider three data items D1, D2 and D3 and the following execution schedule of transactions T1, T2 and T3. In the diagram, R(D) and W(D) denote the actions reading and writing the data item D respectively. Which of the following statements is correct?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/d690aa1d370dd74d-tBNW7txxu8W2OEYp3mJZM1m4TUnsZs.png,The schedule is serializable as T2; T3; T1,,The schedule is serializable as T2; T1; T3,,The schedule is serializable as T3; T2; T1,,The schedule is not serializable,,D,MCQ,"T1 and T2 have conflicting operations between them forming a cycle in the precedence graph.  R(D2) of T2, and W(D2) of T1 ( Read-Write Conflict) R(D1) of T1, and W(D1) of T2 ( Read-Write Conflict)  Hence in the precedence graph of the schedule there would be a cycle between T1 and T2 vertices. Therefore not a serializable schedule.",
27,Which of the following scenarios may lead to an irrecoverable error in a database system ?,,A transaction writes a data item after it is read by an uncommitted transaction,,A transaction reads a data item after it is read by an uncommitted transaction,,A transaction reads a data item after it is written by a committed transaction,,A transaction reads a data item after it is written by an uncommitted transaction,,D,MCQ,"Option C is a normal operation.  Option B is also fine as no write operation is involved.  Option A can be recovered, but option D can't be.",
28,"Let P(E) denote the probability of the event E. Given P(A) = 1, P(B) = 1/2, the values of P(A | B) and P(B | A) respectively are",,"1/4, 1/2",,"1/2, 1/14",,"1/2, 1",,"1, 1/2",,D,MCQ,"Given, [Tex]P(A) = 1[/Tex] , [Tex]P(B) = \frac{1}{2}[/Tex] We need to find the conditional probability of two given events without being told about [Tex]P(A\\cap B)[/Tex] . Also it is not mentioned that they are independent events. But since [Tex]P(A)[/Tex] is 1, it means that [Tex]A[/Tex] covers the complete sample space. So, [Tex]P(A\cap B) = P(B) = \frac{1}{2}[/Tex] [Tex]P(A|B) = \frac{P(A\cap B)}{P(B)} = \frac{1/2}{1/2} = 1\\\\P(B|A) = \frac{P(A\cap B)}{P(A)} = \frac{1/2}{1} = \frac{1}{2}[/Tex]",
29,"A program consists of two modules executed sequentially. Let f1(t) and f2(t) respectively denote the probability density functions of time taken to execute the two modules. The probability density function of the overall time taken to execute the program is given by : A) [Tex] f_{1}(t)+f_{2}(t)[/Tex] B) [Tex]\int_{0}^{t}f_{1}(x)f_{2}(x)dx[/Tex] C) [Tex]\int_{0}^{t}f_{1}(x)f_{2}(t-x)dx[/Tex] D) [Tex]max\left \{ f_{1}(t),f_{2}(t) \right \}[/Tex]",,A,,B,,C,,D,,C,MCQ,"We assume the total time to be ‘t’ units  and f1 executes for 'x’ units.  Since, f1(t) and f2(t) are executed sequentially.  So, f2 is executed for ‘t – x’ units. We apply convolution on the sum of two independent random variables to get probability density function of the overall time taken to execute the program. f1(t) * f2(t – x) = [Tex]\int_{0}^{t}f_{1}(x)f_{2}(t-x)dx[/Tex] Thus, option (C) is correct.",
30,"Let f : A → B be an injective (one-to-one) function. Define g : 2 A → 2 B as : g(C) = {f(x) | x ∈ C}, for all subsets C of A. Define h : 2 B → 2 A as : h(D) = {x | x ∈ A, f(x) ∈ D}, for all subsets D of B. Which of the following statements is always true ?",,g(h(D)) ⊆ D,,g(h(D)) ⊇ D,,g(h(D)) ∩ D = ф,,g(h(D)) ∩ (B - D) ≠ ф,,A,MCQ,,
31,"Let ∑ = {a, b, c, d, e} be an alphabet. We define an encoding scheme as follows : g(a) = 3, g(b) = 5, g(c) = 7, g(d) = 9, g(e) = 11. Let p i denote the i-th prime number (p 1 = 2). For a non empty string s = a 1 , a 2 , ..., a n , where each a i ∈ ∑, define For a non-empty sequence ⟨s j , …, s n ⟩ of strings from Σ + , define Which of the following numbers is the encoding, h, of a non-empty sequence of strings?","https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/68dc6e4380168d4e-MFAbHo9CityuyQuzofWHrZuHmeE2lL.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/020b4846769d8421-KpE3e7q8SSvqjfgXmRtcdX3RHAgKYS.png",2 7 3 7 5 7,,2 8 3 8 5 8,,2 9 3 9 5 9,,2 10 5 10 7 10,,B,MCQ,"Since, the answer is a product of three prime numbers 2, 3 and 5. So, we have three non-empty sequence of strings : ""a"", ""a"" and ""a"". f(s) = 2 x for some x Since, 7 and 9  are not multiple of 2. So, options (A) and (C) are eliminated. f(a) = 2 3 = 8 h = 2 8 3 8 5 8 Thus, option (B) is correct.",
32,"Consider the set ∑* of all strings over the alphabet ∑ = {0, 1}. ∑* with the concatenation operator for strings",,does not form a group,,forms a non-commutative group,,does not have a right identity element,,forms a group if the empty string is removed from ∑*,,A,MCQ,"The given set with the concatenation operator forms a Monoid as it follows the properties of Closure, Associativity and has an identity element(null string). It is not a Group since no element has an inverse element i.e. there is no string S for another string R such that S*R = null string.",
33,"Let (5, ≤) be a partial order with two minimal elements a and b, and a maximum element c. Let P : S → {True, False} be a predicate defined on S. Suppose that P(a) = True, P(b) = False and P(x) ⇒ P(y) for all x, y ∈ S satisfying x ≤ y, where ⇒ stands for logical implication. Which of the following statements CANNOT be true ?",,P(x) = True for all x ∈ S such that x ≠ b,,P(x) = False for all x ∈ S such that x ≠ a and x ≠ c,,P(x) = False for all x ∈ S such that b ≤ x and x ≠ c,,P(x) = False for all x ∈ S such that a ≤ x and b ≤ x,,D,MCQ,"'a' and 'b' are given as minimal elements. No other element in S is of lower order than either a or b.  'c' is given as maximum element. So, c is of higher order than any other element in S. P(a) = True means all elements 'x' which have an edge from element 'a' have to be true. Since there is an edge from 'a', we have to satisfy formula P(a) => P(x), which can only be done by setting  P(x) = True. Elements which have an edge from b can be anything because formula P(b) => P(x) is satisfied as P(b) = False. (A) This statement is true  because making all elements true trivially satisfy formula P(x) => P(y). (B) This statement is true  if all elements are connected from b then all elements can be false. (C) This statement is true because b<=x ensures  x!=a  and for all other elements P(x) can be false without violating the given implication. (D) This statement is false. Since, P(a) = true , for all 'x' such that a<=x, P(x) must be true. We do have at least one such 'x', which is 'c' as it is the maximum element. Thus, option (D) is the answer.",
34,"Consider the following circuit composed of XOR gates and non-inverting buffers. The non-inverting buffers have delays d1 = 2 ns and d2 = 4 ns as shown in the figure. Both XOR gates and all wires have zero delay. Assume that all gate inputs, outputs and wires are stable at logic level 0 at time 0. If the following waveform is applied at input A, how many transition(s) (change of logic levels) occur(s) at B during the interval from 0 to 10 ns ?","https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/3eb529ce1618bd3e-qGD3JFFYDR4dqz16RruO0U1buKATdx.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/c01f649ae890d0e6-YGmsLWI8dExVSvktlZhyPq5nZkYIrX.png",1,,2,,3,,4,,D,MCQ,"As we draw wave forms of different inputs: The 2ns buffer input is shifted form of A The output of first EXOR gate is a single beat of 1 through 3 While this is shifted by the 4ns buffer Which in-turn results in two beats output from the second EXOR gate Hence 4 transitions, so option (D) is correct.",
35,"Consider an array multiplier for multiplying two n bit numbers. If each gate in the circuit has a unit delay, the total delay of the multiplier is",,Θ(1),,Θ(log n),,Θ(n),,Θ(n 2 ),,C,MCQ,"Number of gates used in ‘n’ bit array multiplier (n * n) = (2n – 1)  Each gate in the circuit has a unit delay.   Total delay, = 1 * (2n – 1) = O(2n – 1) = O(n) Suppose 2 numbers A and B.  Take, A = A0 A1 A2 A3 B = B0 B1 B2 B3 For multiplying A and B we need to do, Multiply A0 A1 A2 A3 with B1 need 1 AND gate Multiply A0 A1 A2 A3 with B2 need 1 AND gate Multiply A0 A1 A2 A3 with B3 need 1 AND gate Multiply A0 A1 A2 A3 with B4 need 1 AND gate Also 3 OR gates are required to add terms got by AND gates.  So, total gates required = 4+3 = 7 that is 2N-1.  So, Time complexity = ϴ(n) Option (C) is correct.",
36,"Consider the ALU shown below. If the operands are in 2's complement representation, which of the following operations can be performed by suitably setting the control lines K and C0 only (+ and - denote addition and subtraction respectively) ?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/895cc2c4df7436d7-zWOLBQz9OuzaZqo9tFfMA5bvT7e4hz.png,"A + B, and A - B, but not A + 1",,"A + B, and A + 1, but not A - B",,"A + B, but not A - B, or A + 1",,"A + B, and A - B, and A + 1",,A,MCQ,"We can set value of k and c as 0 or 1  Two things we need to know--- If we take xor of any number with 1 we get it in its complement form. If we take xor of any number with 0 we get that number itself. So on setting k=1 we can get –B and c will work like select signal  Like c=0 means add  C=1 means subtract  Hence with k=1 c=1 we get A-B  With K=0 c=0 we get A+B  We need b=1,c=0 or b=0,c=1 to get A+1  since b isn't predefined we can't get A+1  So Ans is (A) part.",
37,"The literal count of a boolean expression is the sum of the number of times each literal appears in the expression. For example, the literal count of (xy + xz') is 4. What are the minimum possible literal counts of the product-of-sum and sum-of-product representations respectively of the function given by the following Karnaugh map ? Here, X denotes ""don't care""",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/765666f13c37df28-43v0kZKD5aXuUbj4ML5Ks6Iq7us5Kd.jpg,"(11, 9)",,"(9, 13)",,"(9, 10)",,"(11, 11)",,C,MCQ,"Analyzing both POS as well as SOP Sop- wy+w’y’+z’wx’+xyz’  Literal count=10  Pos--- (w’+z’)(x’+y)(z+w+x)(z’+y’)  Literal count=9  So, option (C) is correct.",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/8d2fca2cf470a198-bGjLmTDyTdiF0iEjH9bQIdKaCb5UH3.webp
38,"A 1-input, 2-output synchronous sequential circuit behaves as follows : Let zk, nk denote the number of 0's and 1's respectively in initial k bits of the input (zk + nk = k). The circuit outputs 00 until one of the following conditions holds. zk - nk = 2. In this case, the output at the k-th and all subsequent clock ticks is 10. nk - zk = 2. In this case, the output at the k-th and all subsequent clock ticks is 01. What is the minimum number of states required in the state transition graph of the above circuit?",,5,,6,,7,,8,,A,MCQ,"The answer must be 5 to this question as we just need to count the difference of the number of 0's and 1's in the first k bit of a number. And we just need to count till this count reaches 2 or -2 (negative when number of 0's is less than number of 1's) . So, the possibilities are -2, -1, 0, 1 and 2 which represents the five states of the state transition diagram. For state -2, the output of the circuit will be 01, for state 2, output will be 10 (both these states not having any outgoing transitions) and for other 3 states, output will be 00 as per the given description of the circuit.",
39,The regular expression 0*(10*)* denotes the same set as,,(1*0)*1*,,0 + (0 + 10)*,,(0 + 1)* 10(0 + 1)*,,none of these,,A,MCQ,"There is property of regular expression (a+b)* = (a*b*)* = (a*+b*)* = (a*+b)* = a*(ba*)*= (b*a)*b*.  (1*0)*1* can generate all strings that generated by given regular expression 0*(10*)*.  So, option (A) is correct.",
40,"Consider the NFA M shown below. Let the language accepted by M be L. Let L1 be the language accepted by the NFA M1, obtained by changing the accepting state of M to a non-accepting state and by changing the non-accepting state of M to accepting states. Which of the following statements is true ?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/9e1cb9ffc5bc9dfa-IrNb0deps8cMJVHWNtBimC6jdOzF3L.jpg,"L1 = {0, 1}* - L",,"L1 = {0, 1}*",,L1 ⊆ L,,L1 = L,,B,MCQ,"In case of a Deterministic Finite Automata (DFA) when we change the accepting states into non-accepting states and non-accepting states into accepting states, the new DFA obtained accepts the complement of the language accepted by the initial DFA. It is because we have one single movement for a particular input alphabet from one state so the strings accepted by the transformed DFA will be all those which are not accepted by the actual DFA. But it is not the case with the NFA’s (Non-Deterministic Finite Automata). In case of NFA we need to have a check on the language accepted by the NFA. The NFA obtained by changing the accepting states to non-accepting states and non-accepting states to accepting states is as follows:- Here we can see that as i.  The initial state is an accepting state hence null string is always accepted by the NFA. ii. There is a movement from state 1 to state 2 on both {0, 1} input alphabets and further any  number of 1’s and 0’s or even none in the string lets the string be at an accepting state(state 2). Hence the language accepted by the NFA can be any string with any combination of 0’s and 1’s including a null string i.e. {null, 0, 1, 00, 01, 10, 11,……………..} so L1= {0, 1}*.",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/0db52cf2d2abe1d3-HMV4vjecMW2OOzLcArwfPIseMnZPRL.jpg
41,"Consider the following deterministic finite state automaton M. Let S denote the set of seven bit binary strings in which the first, the fourth, and the last bits are 1. The number of strings in S that are accepted by M is",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/10c83b80f606c00b-YyF2jglayNp8d8gYrpU7h1oN2nM8ne.png,1,,5,,7,,8,,C,MCQ,"Given a language of 7 bit strings where 1st, 4th and 7th bits are 1.  The following are 7 strings of language that can be accepted by DFA.  1001001 1001011 1001101 1001111  1101001 1111001 1011001",
42,"If the strings of a language L can be effectively enumerated in lexicographic (i.e., alphabetic) order, which of the following statements is true ?",,L is necessarily finite,,L is regular but not necessarily finite,,L is context free but not necessarily regular,,L is recursive but not necessarily context free,,D,MCQ,"The strings of a language L can be effectively enumerated  means a Turing machine exists for language L  which will enumerate all valid strings of the language. If the string is in lexicographic order  then TM will accept the string and halt in the final state. But, if the string is not lexicographic order then TM will reject the string and halt in non-final state. Thus, L is recursive language. We can not construct PDA for language L. So, the given language is not context free.  Thus, option (D) is correct.",
43,"Let G = ({S}, {a, b} R, S) be a context free grammar where the rule set R is S → a S b | SS | ε Which of the following statements is true?",,G is not ambiguous,,"There exist x, y, ∈ L (G) such that xy ∉ L(G)",,There is a deterministic pushdown automaton that accepts L(G),,We can find a deterministic finite state automaton that accepts L(G),,C,MCQ,"An ambiguous grammar can be converted to unambiguous one. Here we can get grammar in partial GNF form as S -> ab | abS | aSb | aSbS We can convert this into GNF too but no need for PDA reasoning so, above grammar is not a ambiguous thus a definite PDA possible Trick for this is but just deriving 3-4 strings from grammar, we can easily understand its (a n b n )* above expression a n b n is in CFL thus closure of DCFG is a DCFG i.e., you can get L = {ε, ab, abab, aabb, aabbab, abaabb, ababab,......} PDA will push ""a"" until ""b"" is read, start popping ""a"" for the ""b"" read. If ""a"" is read again from the tape then push only when stack is empty else terminate. Repeat this until string is read.",
44,Nobody knows yet if P = NP. Consider the language L defined as follows : Which of the following statements is true ?,https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/54c6a6ef024a4af1-hqcQrQaPp4bChMiUjD44fsayjKtBAv.png,L is recursive,,L is recursively enumerable but not recursive,,L is not recursively enumerable,,Whether L is recursive or not will be known after we find out if P = NP,,A,MCQ,"Answer is A. in both case(P = NP or P != NP) L is regular, so L is recursive.  Thanks to Vikrant for the above explanation.",
45,"Define languages L0 and L1 as follows : L0 = {< M, w, 0 > | M halts on w} L1 = {< M, w, 1 > | M does not halts on w} Here < M, w, i > is a triplet, whose first component. M is an encoding of a Turing Machine, second component, w, is a string, and third component, i, is a bit. Let L = L0 ∪ L1. Which of the following is true ?",,"L is recursively enumerable, but L' is not",,"L' is recursively enumerable, but L is not",,Both L and L' are recursive,,Neither L nor L' is recursively enumerable,,D,MCQ,"Since Halting problem of Turing Machines is undecidable. So, L = L0 ∪ L1 is undecidable even not semi-decidable. That is not recursive enumerable , therefore, its complement (L') is also not recursive enumerable.   Option (D) is correct.",
46,"A single tape Turing Machine M has two states q0 and q1, of which q0 is the starting state. The tape alphabet of M is {0, 1, B} and its input alphabet is {0, 1}. The symbol B is the blank symbol used to indicate end of an input string. The transition function of M is described in the following table 0 1 B q0 q1, 1, R q1, 1, R Halt q1 q1, 1, R q0, 1, L q0, B, L The table is interpreted as illustrated below. The entry (q1, 1, R) in row q0 and column 1 signifies that if M is in state q0 and reads 1 on the current tape square, then it writes 1 on the same tape square, moves its tape head one position to the right and transitions to state q1.  Which of the following statements is true about M ?",,M does not halt on any string in (0 + 1)+,,M does not halt on any string in (00 + 1)*,,M halts on all string ending in a 0,,M halts on all string ending in a 1,,A,MCQ,"Whenever B is given as a input, turing machine halts. This implies epsilon is only accepted when B occurs as an input. In positive closure, epsilon is not present. So, Turing machine never halts in case of (0+1) + . Thus, option (A) is correct.",
47,"Consider two languages L1 and L2 each on the alphabet ∑. Let f : ∑ → ∑ be a polynomial time computable bijection such that (∀ x) [x ∈ L1 if f(x) ∈ L2]. Further, let f -1 be also polynomial time computable. Which of the following CANNOT be true?",,L1 ∈ P and L2 is finite,,L1 ∈ NP and L2 ∈ P,,L1 is undecidable and L2 is decidable,,L1 is recursively enumerable and L2 is recursive,,C,MCQ,"We have one to one mapping for all instances of L1 to L2. L1 is given to be undecidable. Further L1 is polynomial time reducible to L2. (By given mapping). Now if L2 is decidable then there is algorithm to solve L2 in polytime. But then we can solve every instance of L1 in polytime, making L1 also decidable. Contradiction",
48,"A piecewise linear function f(x) is plotted using thick solid lines in the figure below (the plot is drawn to scale). If we use the Newton-Raphson method to find the roots of f(x) = 0 using x0, x1 and x2 respectively as initial guesses, the roots obtained would be",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/6fe4d9b093bcefb2-9nZxedjRrkW9JpW6pOtNkzi3XFHgV9.jpg,"1.3, 0.6, and 0.6 respectively",,"0.6, 0.6, and 1.3 respectively",,"1.3, 1.3, and 0.6 respectively",,"1.3, 0.6, and 1.3 respectively",,D,MCQ,"First of all, There is a mistake in coordinates of a given point. I have corrected that in red color. Now in Newton-Raphson method, we draw a tangent from our guess point, and our new guess would be the point where this tangent cuts x-axis. Now we choose initial guess points one by one : x0 : Tangent at this point is line AB itself, and that would cut x-axis at point (1.0,0.0)  (found using equation of line AB). So our next guess would be 1.0. Point on the curve corresponding to this new guess 1.0 is shown as F. Now tangent at point F is line DE,   which cuts x-axis at 1.3, and at this point, value of function is zero, so we found  the root as 1.3. x1 : Tangent at this point is line BE, which cuts x-axis at 0.6, also function value is zero here, so we find root as 0.6. x2 : Tangent at this point is line CD, which cuts x-axis at 1.05 (again found by finding equation of line CD). Point on the curve corresponding to this new guess 1.05 is shown as G. Now tangent at point G is line DE, which cuts x-axis at 1.3, and at this point, value of function is zero, so we found the root as 1.3.",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/629a65d1e049fdb6-kn2k5D3DSPOGBnV3e0BNoEWEzgDtEu.jpg
49,"A graph G = (V, E) satisfies |E| ≤ 3 |V| - 6. The min-degree of G is defined as . Therefore, min-degree of G cannot be",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/851bc53fb145b998-RnUEjpEPXf9bNh0Klm03zfPxS9ucbh.png,3,,4,,5,,6,,D,MCQ,"Let the min-degree of G be x, then G has at least |v| *x/2 edges.

|v|*x/2 <= 3* |v| -6

for x=6, we get 0 <= -6, Therefore, min degree of G cannot be 6.

Hence answer is (D).",
50,"Let G be an arbitrary graph with n nodes and k components. If a vertex is removed from G, the number of components in the resultant graph must necessarily lie between",,k and n,,k - 1 and k + 1,,k - 1 and n - 1,,k + 1 and n - k,,C,MCQ,Minimum:  The removed vertex itself is a separate connected component.  So removal of a vertex creates k-1 components.  Maximum:  It may be possible that the removed vertex disconnects all components.  For example the removed vertex is center of a star. So removal creates n-1 components.,
51,How many perfect matchings are there in a complete graph of 6 vertices ?,,15,,24,,30,,60,,A,MCQ,"A perfect matching, every vertex of the graph is incident to exactly one edge of the matching. A perfect matching is therefore a matching of a graph containing n/2 edges, the largest possible, meaning perfect matchings are only possible on graphs with an even number of vertices.",
52,"m identical balls are to be placed in n distinct bags. You are given that m ≥ kn, where, k is a natural number ≥ 1. In how many ways can the balls be placed in the bags if each bag must contain at least k balls?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/d2956e27f4757c20-mnoztRbCt3ShlupBKGfmFykyS3hiFi.png,C,,D,,B,,A,,C,MCQ,"This is very simple application of stars and bars . Since we want atleast k balls in each bag, so first we put kn balls into bags, k balls in each bag. Now we are left with m - kn balls, and we have to put them into n bags such that each bag may receive 0 or more balls. So applying theorem 2 of stars and bars with m - nk stars and n bars, we get number of ways to be m−kn+n-1 C n−1 . So option (B) is correct.",
53,"Let A be a sequence of 8 distinct integers sorted in ascending order. How many distinct pairs of sequences, B and C are there such that (i) each is sorted in ascending order, (ii) B has 5 and C has 3 elements, and (iii) the result of merging B and C gives A?",,256,,56,,30,,2,,B,MCQ,"Suppose you have selected 3 elements from 8 in 8C3 ways, the remaining elements are treated as another array and merging both the arrays gives the sorted array. Here, you can select either 3 or 5. => 8C3 = 8C5 = 8!/(3!5!) = 7*8 = 56 Ways.",
54,"n couples are invited to a party with the condition that every husband should be accompanied by his wife. However, a wife need not be accompanied by her husband. The number of different gatherings possible at the party is",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/cf9f1360cb1ff030-J0odnOdg2obWcikUU7c32SYV5TULmw.png,A,,B,,C,,D,,B,MCQ,"There are three options for every couple. 1) Nobody goes to gathering 2) Wife alone goes 2) Both go Since there are n couples, total possible ways of gathering are 3 n",
55,"For a pipelined CPU with a single ALU, consider the following situations 1. The j + 1-st instruction uses the result of the j-th instruction as an operand 2. The execution of a conditional jump instruction 3. The j-th and j + 1-st instructions require the ALU at the same time Which of the above can cause a hazard ?",,1 and 2 only,,2 and 3 only,,3 only,,All of above,,D,MCQ,Case 1: Is of data dependency .this can’t be safe with single ALU so read after write. Case 2:Conditional jumps are always hazardous they create conditional dependency in pipeline. Case 3:This is write after read problem or concurrency dependency so hazardous All the three are hazardous So (D) is correct option .,
56,Which of the following assertions is FALSE about the Internet Protocol (IP) ?,,It is possible for a computer to have multiple IP addresses,,IP packets from the same source to the same destination can take different routes in the network,,IP ensures that a packet is discarded if it is unable to reach its destination within a given number of hops,,The packet source cannot set the route of an outgoing packets; the route is determined only by the routing tables in the routers on the way,,D,MCQ,"See following liens from In computer networking, source routing allows a sender of a packet to partially or completely specify the route the packet takes through the network. In the Internet Protocol, two header options are available which are rarely used: ""strict source and record route"" (SSRR) and ""loose source and record route"" (LSRR). Because of security concerns, packets marked LSRR are frequently blocked on the Internet. If not blocked, LSRR can allow an attacker to spoof its address but still successfully receive response packets.",
57,Which of the following functionalities must be implemented by a transport protocol over and above the network protocol ?,,Recovery from packet losses,,Detection of duplicate packets,,Packet delivery in the correct order,,End to end connectivity,,D,MCQ,"End to end connectivity is the required functionality provided by Transport protocol. UDP of transport layer protocol that doesn't implement other three functionalities, they are implemented only in TCP.",
58,Consider the following formula a and its two interpretations I1 and I2 Which of the following statements is true?,https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/5f5f8e2614e454a6-oEgHpTftL6MyCaeLHtTHHbT77EtwcF.png,"I2 satisfies α, I1 does not",,Neither I2 nor I2 satisfies α,,Both I1 and I2 satisfy α,,"I1 satisfies α, I2 does not",,C,MCQ,"First of all, note that, in α, ¬Qyy is always false, because every number divides itself. Also not that rightmost formula (∀x)[¬Px] is always false, because clearly it is not the case that every number is not the prime number (in case of I1), nor it is the case that every number is not the composite number (in case of I2). Also note that, variable x in this expression is not same as variable x in leftside expression, they are independent. In fact, we can rewrite α as α:(∀x)[Px⇔(∀y)[Qxy⇔¬Qyy]]⇒(∀z)[¬Pz]. Let us consider I1 first. So let us assign some value to x, and see if it satisfies α. We can partition assignments of x into 3 parts : when x is prime, when x is composite, when x is 1. When x is prime : Px is true, also Qxy is false for all y except 1, because only 1 divides x. So formula Qxy⇔¬Qyy is true for all y except 1, but due to ∀y outside this, whole formula ∀y[Qxy⇔¬Qyy] becomes false, because it would have been true if Qxy⇔¬Qyy was true for every y. So now [Px⇔(∀y)[Qxy⇔¬Qyy]] becomes false for all x whenever x is prime. Since for some x (where x is prime), [Px⇔(∀y)[Qxy⇔¬Qyy]] is false, so (∀x)[Px⇔(∀y)[Qxy⇔¬Qyy]] is definitely false, since false⇒ false is true, so α is true in I1, and we don't need other cases of x. Now consider I2. Here also we can argue in the same way as we did in cases of I1, here case of x being composite leads to false⇒false, and so α is also true in I2, hence option (D) is correct.",
59,"Consider the following logic program P A(x) <- B(x, y), C(y)      <- B(x,x) Which of the following first order sentences is equivalent to P?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/4d03e3ffd5d8fc90-jIgpOUEneMAcP4y4qpK11ti8B0gGb4.png,A,,B,,C,,D,,C,MCQ,,
60,"The following resolution rule is used in logic programming. Derive clause (P ∨ Q) from clauses (P ∨ R), (Q ∨ ¬R) Which of the following statements related to this rule is FALSE?",,((P ∨ R) ∧ (Q ∨ ¬R)) ⇒ (P ∨ Q) is logically valid,,(P ∨ Q) ⇒ ((P ∨ R)) ∧ (Q ∨ ¬R)) is logically valid,,(P ∨ Q) is satisfiable if and only if (P ∨ R) ∨ (Q ∨ ¬R) is satisfiable,,(P ∨ Q) ⇒ FALSE if and only if both P and Q are unsatisfiable,,B,MCQ,"Option A: According to the resolution principle, (P+R)(Q+R’) -> (P+Q), hence this is correct. Option B: (P+Q) -> (P+R)(Q+R’) = P’Q’ + PQ + P’R’ + QR. This is the converse of the Resolution Principle and the converse function does not work in Resolution Principle. Hence, this is false, and therefore Option B is correct. Option C: Any formula can be satisfiable only if at least one true exists in its truth table. Consider here: α = P + Q and β = (P + R)(Q + R’) For α to be satisfiable, we must have P = 1, and Q = 1, then in that case β is also satisfiable. For β to be satisfiable, we must have P = 1, Q = 0, and R = 0, then in that case, α is also satisfiable. Therefore, the statement in option C is also valid. Option D: Consider here, Let us take α = (P+Q) as false and β: both P and Q are unsatisfiable. α is true when only when P = false and Q = false, otherwise false in every case. β is true only when P = false and Q = false and otherwise false in every case. This implies that α ≣ β. Hence, the statement in Option D is also correct. Conclusion: As the question is asking which option is not correct, Hence Option B is the correct answer.",
61,Which of the following is a valid first order formula ? (Here α and β are first order formulae with x as their only free variable),https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/b658794f65978905-5BAAavv4NkT77Wpm1EEmCnU9KMMwYK.png,A,,B,,C,,D,,D,MCQ,,
62,Which of the following statements is FALSE ?,,"In statically typed language, each variable in a program has a fixed type",,"In un-typed languages, values do not have any types",,"In dynamically typed languages, variables have no types",,"In all statically typed languages, each variable in a program is associated with values of only a single type during the execution of the program",,C,MCQ,"This is an ambiguous question. ""Untyped language"" has no standard well-formulated definition, thus answering this question would be a bit difficult. (A) Statically typed languages have one type associated to a variable, which is fixed once it has been deduced. Though, types could either be specified while code editing by the coder (Eg. C, Java), or it can be inferred at compile time (Eg. C++11, Haskell). Hence, after compile-time, every variable is bound to one fixed type, making this statement [TRUE] (B) According to one definition, un-type languages store values in form of bits, thus neither variables nor values have any types associated to them. Hence this statement becomes [TRUE] (C) Dynamically typed languages deduce types of values and bind them to the variables storing those values. Hence, values sure have fixed types, but variables don't have fixed types bound to them. Although we can say that binding a type to a variable according to values makes them typeful, but they don't have one fixed type. This statement has some ambiguity. [TRUE/FALSE] (D) Same reason as of (A) [TRUE]  Hence, correct answer should be (C)",
63,"The following program fragment is written in a programming language that allows variables and does not allow nested declarations of functions. C global int i = 100 , j = 5 ; void P ( x ) { int i = 10 ; print ( x + 10 ); i = 200 ; j = 20 ; print ( x ); } main () { P ( i + j ); } If the programming language uses static scoping and call by need parameter passing mechanism, the values printed by the above program are",,"115, 220",,"25, 220",,"25, 15",,"115, 105",,D,MCQ,"Background : Call-by-need is a declarative and functional language paradigm. As opposed to call-by-value, it only evaluates the argument given to a function when it is need, and caches it for further use. Call-by-name is a bit different from call-by-need in the sense that it evaluates in the lazy fashion only but doesn’t cache the calculated value. Hence, call-by-need requires to evaluate once if the argument is being used, call-by-value needs to evaluate it no matter if the argument is used or not, and call-by-name evaluates the same argument multiple times as and when it is used. Explanation : Value of variable x doesn’t change anytime in the function P(x). Hence, whatever its value is when this function is called, only that will be used in all the print statements. Clearly, 100+5+10, 100+5 i.e. 115, 105 will be printed by the program.    This solution is contributed by vineet purswani Another Solution: Here in main function P(i+j) function is called with arguments values i =100 and j = 5(since static scoping).Now when P(100+5) is called, here in P function, j is a free variable and i is a local variable.Now take a look at the steps in P function : step_1: Local variable i is initialized to value 0. step_2: Here value of x+10 is printed and since it’s call by need,so value of x is calculated to 105 and it’s stored in cache for further use.Also 115 is printed here. step_3: Now, i is assigned value 200. step_4: Here, j is a free variable, So it’s scope is searched in immediate outer block until we find variable j’s declaration.Global variable j’s value is changed from 5 to 20. step_5: x value is printed as 105.Since it’s uses the cache stored value of x.  The output would be similar to C programming language as C does Static Scoping only.",
64,"The following program fragment is written in a programming language that allows variables and does not allow nested declarations of functions. C global int i = 100 , j = 5 ; void P ( x ) { int i = 10 ; print ( x + 10 ); i = 200 ; j = 20 ; print ( x ); } main () { P ( i + j ); } If the programming language uses dynamic scoping and call by name parameter passing mechanism, the values printed by the above program are :",,"115, 220",,"25, 220",,"25, 15",,"115, 105",,A,MCQ,"C global int i = 100 , j = 5 ; void P ( x ) // x = i + j { int i = 10 ; print ( x + 10 ); // print (100+5+10) = 115 i = 200 ; j = 20 ; print ( x ); // print (200+20) = 220. // i and j would be changed as they are global variables } main () { P ( i + j ); } Thus, A is the correct option as 115 and 220 are printed.",
65,"Consider the following class definitions in a hypothetical Object Oriented language that supports inheritance and uses dynamic binding. The language should not be assumed to be either Java or C++, though the syntax is similar. Class P { void f(int i) { print(i); } } Class Q subclass of P { void f(int i) { print(2*i); } } Now consider the following program fragment: P x = new Q(); Q y = new Q(); P z = new Q(); x.f(1); ((P)y).f(1); z.f(1); Here ((P)y) denotes a typecast of y to P. The output produced by executing the above program fragment will be",,1 2 1,,2 1 1,,2 1 2,,2 2 2,,D,MCQ,Since the question itself tells us that the language uses dynamic binding therefore all the function calls should be considered only on the basic of type of object stored.,
66,"Assuming all numbers are in 2's complement representation, which of the following numbers is divisible by 11111011?",,11100111,,11100100,,11010111,,11011011,,A,MCQ,"Since most significant bit is 1, all numbers are negative.  2's complement of divisor (11111011) = 1's complement  + 1 = 00000100 + 1 = 00000101 So the given number is -5   The decimal value of option A is -25",
67,"The following is a scheme for floating point number representation using 16 bits. Bit position 15           14 . . . 9            8 . . . . .0 s                      e                      m Sign                  Exponent               Mantissa Let s,e, and m be the numbers represented in binary in the sign, exponent, and mantissa fields respectively. Then the floating point number represented is: What is the maximum difference between two successive real numbers representable in this system?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/62426b83fcc61f0d-sPqL0dQHvRZN3g9zEHiyHl9mSAMFsN.png,2- 40,,2 -9,,2 22,,2 31,,C,MCQ,,
68,"Consider the following assembly language program for a hypothetical processor. A, B, and C are 8 bit registers. The meanings of various instructions are shown as comments. MOV B, # 0 ; B ← 0 MOV C, # 8 ; C ← 8 Z : CMP C, # 0 ; compare C with 0 JZX ; jump to X if zero flag is set SUB C, # 1 ; C ← C - 1 RRC A, # 1 ; right rotate A through carry by one bit. Thus: ; if the initial values of A and the carry flag are a 7 ...a 0 and ; c 0 respectively, their values after the execution of this ; instruction will be c 0 a 7 ...a 1 and a 0 respectively. JC Y ; jump to Y if carry flag is set JMP Z ; jump to Z Y : ADD B, # 1 ; B ← B + 1 JMP Z ; jump to Z X : Which of the following instructions when inserted at location X will ensure that the value of register A after program execution is the same as its initial value ?",,"RRC A, #",,NOP ; no operation,,"LRC A, # 1 ; left rotate A through carry flag by one bit",,"ADD A, # 1",,A,MCQ,"Explanation In the end of program execution to check whether both initial and final value of register A is A0,we need to right rotate register A through carry by one bit because RRC instruction is( Each binary bit of the accumulator is rotated right by one position. Bit D0 is placed in the position of D7 as well as in the Carry flag. CY is modified according to bit D0. Any other bit is not affected). So (A) is correct option",
69,"Consider the following assembly language program for a hypothetical processor. A, B, and C are 8 bit registers. The meanings of various instructions are shown as comments. MOV B, # 0 ; B ← 0 MOV C, # 8 ; C ← 8 Z : CMP C, # 0 ; compare C with 0 JZX ; jump to X if zero flag is set SUB C, # 1 ; C ← C - 1 RRC A, # 1 ; right rotate A through carry by one bit. Thus: ; if the initial values of A and the carry flag are a 7 ...a 0 and ; c 0 respectively, their values after the execution of this ; instruction will be c 0 a 7 ...a 1 and a 0 respectively. JC Y ; jump to Y if carry flag is set JMP Z ; jump to Z Y : ADD B, # 1 ; B ← B + 1 JMP Z ; jump to Z X :",,the number of 0 bits in A0,,the number of 1 bits in A0,,A0,,8,,B,MCQ,"Answer: (B) Explanation:  Explanation: Here value of B incremented by 1 only if carry flag is 1 and carry is filled always using right rotation. So B will store the no. of 1s in A0. RRC instruction is ( Each binary bit of the accumulator is rotated right by one position. Bit D0 is placed in the position of D7 as well as in the Carry flag. CY is modified according to bit D0. Any other bit is not affected). So A=A0, and after execution RRC A,#1, carry flag is set, it goes to Y, which is B=B+1,Which becomes B=0+1=1   So (B) is correct option",
70,"A uni-processor computer system only has two processes, both of which alternate 10ms CPU bursts with 90ms I/O bursts. Both the processes were created at nearly the same time. The I/O of both processes can proceed in parallel. Which of the following scheduling strategies will result in the least CPU utilization (over a long period of time) for this system ?",,First come first served scheduling,,Shortest remaining time first scheduling,,Static priority scheduling with different priorities for the two processes,,Round robin scheduling with a time quantum of 5 ms,,D,MCQ,"FCFS (First Come First Serve) Processes take turns using CPU. CPU is idle when both are in I/O. Since I/O bursts are long (90 ms), the CPU may often be idle i.e low CPU utilization. Round Robin Same as FCFS for CPU-intensive bursts (10 ms each). CPU idle occurs similarly  utilization slightly better if context switching overlaps. SJF or SRTF : Each CPU burst is equal (10 ms), so no advantage → same idle periods. Multiprogramming / overlapped I/O If more processes were available, CPU could stay busy  higher utilization. But here only 2 processes  CPU idle for most of the I/O period. Answer : FCFS results in the least CPU utilization.",
71,"Consider the function f defined below. C struct item { int data ; struct item * next ; }; int f ( struct item * p ) { return (( p == NULL ) || ( p -> next == NULL ) || (( P -> data <= p -> next -> data ) && f ( p -> next ))); } For a given linked list p, the function f returns 1 if and only if",,the list is empty or has exactly one element,,the elements in the list are sorted in non-decreasing order of data value,,the elements in the list are sorted in non-increasing order of data value,,not all elements in the list have the same data value.,,B,MCQ,See http://geeksquiz.com/data-structures-linked-list-question-11/,
72,The subnet mask for a particular network is 255.255.31.0. Which of the following pairs of IP addresses could belong to this network?,,172.57.88.62 and 172.56.87.233,,10.35.28.2 and 10.35.29.4,,191.203.31.87 and 191.234.31.88,,128.8.129.43 and 128.8.161.55,,D,MCQ,"Background required - Subnet and SubNet Mask  Answer - D  Explanation - Suppose we have a host A with IP Address IP A and Subnet mask of the subnet of which A is a part is M s . Now when A wants to send packet to a host B with an IP address say IP B , then A will first AND the subnet-Mask M s with IP A to find out the subnet-id ID N of the subnet in order to identify whether IP B belongs to the same network. Now if B also belongs to the same network, then IP B BITWISE-AND M s must be equal to ID N which A has calculated.  If IP A and IP B belongs to same network, we must have IP A BITWISE-AND M s == IP B BITWISE-AND M s Out of the 4 options, only option D matches. 128.8.129.43 BITWISE-AND 255.255.31.0 = 128.8.1.0 128.8.161.55 BITWISE-AND 255.255.31.0 = 128.8.1.0",
73,"Assume the following C variable declaration C int * A [ 10 ], B [ 10 ][ 10 ]; Of the following expressions : A[2] A[2][3] B[1] B[2][3] which will not give compile-time errors if used as left hand sides of assignment statements in a C program?",,"I, II, and IV only",,"II, III, and IV only",,II and IV only,,IV only,,A,MCQ,"Among expressions I (A[2]), II (A[2][3]), III (B[1]), and IV (B[2][3]), only III (B[1]) will yield a compile-time error when used as the left-hand side of assignment statements. Arrays aren't assignable in C. The rest are valid assignments referencing pointers or specific array elements.",
74,"Let S be a stack of size n ≥ 1. Starting with the empty stack, suppose we push the first n natural numbers in sequence, and then perform n pop operations. Assume that Push and pop operation take X seconds each, and Y seconds elapse between the end of one such stack operation and the start of the next operation. For m ≥ 1, define the stack-life of m as the time elapsed from the end of Push(m) to the start of the pop operation that removes m from S. The average stack-life of an element of this stack is",,n (X + Y),,3Y + 2X,,n (X + Y) - X,,Y + 2X,,C,MCQ,"Background required - Stack and Basic Maths Let Tn be time span of nth element of stack. Let us first find out the sum of Tn for n = 1 to n Stack Lifetime of last element, Tn = Y (Since it is popped as soon as it is pushed on the stack) Stack Lifetime of last element, Tn-1 = Tn  + 2X + 2Y (The time needed to push and then pop nth element plus two pauses Y each). = 2X + 3Y Stack Lifetime of last element, Tn-2 = Tn-1  + 2X + 2Y (Using the Same reasoning above) = 4X + 5Y . . . Stack Lifetime of 1st element = 2(n-1)X + (2n-1)Y	(Generalizing the pattern) Sum of all the time spans of all the elements = (Σ 2(n-1)X) + (Σ (2n-1)Y) for n = 1 to n = 2X(1 + 2 + . . . + n-1) + Y(1 + 3 + 5 + . . . + (2n-1)) Using 2 identities Sum of n natural numbers = (n*(n+1))/2 for the first summation Sn = (n/2)(a+l)	  Sum of AP series with a as first term and l being last for second summation Above sum is,  = (2X(n-1)n)/2 + Y(n/2)*(1 + 2n-1)  = n(n(X+Y)-X)  Therefore Average = Sum/n = n(X+Y)-X .  Hence Option (c)",
75,"Consider the following C function. C float f ( float x , int y ) { float p , s ; int i ; for ( s = 1 , p = 1 , i = 1 ; i < y ; i ++ ) { p *= x / i ; s += p ; } return s ; } For large values of y, the return value of the function f best approximates",,x^y,,e^x,,ln(1 + x),,x^x,,B,MCQ,"The provided function computes the sum of a Taylor series approximation for (e^x) up to the (y)th term. This function is essentially approximating the exponential function (e^x). For large values of (y), the function will approximate (e^x) more accurately because it includes more terms of the Taylor series expansion, resulting in a better approximation. Therefore, for large values of (y), the return value of the function (f(x, y)) will best approximate (e^x). Now,expanding e x =1+x+x 2 /2+x 3 /3+x 4 /4......... So final answer should be e x",
76,"Suppose the numbers 7, 5, 1, 8, 3, 6, 0, 9, 4, 2 are inserted in that order into an initially empty binary search tree. The binary search tree uses the usual ordering on natural numbers. What is the in-order traversal sequence of the resultant tree ?",,7 5 1 0 3 2 4 6 8 9,,0 2 4 3 1 6 5 9 8 7,,0 1 2 3 4 5 6 7 8 9,,9 8 6 4 2 3 0 1 5 7,,C,MCQ,Inorder traversal of Binary Search Tree always produces keys in increasing order.,
77,"Consider the following graph, Among the following sequences: (I) a b e g h f (II) a b f e h g (III) a b f h g e (IV) a f g h b e Which are depth first traversals of the above graph?",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/972c56e5c66b7b91-lv5kKCeNN17SOkhC31LVf8PFNKuVt1.gif,"I, II and IV only",,I and IV only,,"II, III and IV only",,"I, III and IV only",,D,MCQ,"DFS of a graph 1) Visits a node. 2) Do following for every unvisited adjacent. a) Completely explores all vertices through current adjacent using recursive call to DFS. There can be any DFS possible as we may pick different vertices as starting points and we may pick adjacents in different orders. (i) a b e g h f [Visit a, explore all adjacents through b, and so on..]. In this b's adjacent e is picked first (iii) a b f h g e [Visit a, explore all adjacents through b, and so on..]. In this b's adjacent f is picked first (iv) a f g h b e [Visit a, explore all adjacents through f, and so on..]. In this f's adjacent g is picked first (ii) a b f e h g can not be an answer as e is visited after f [e is not an adjacent of f and all adjacent of f are not explored yet]",
78,"The usual Θ(n 2 ) implementation of Insertion Sort to sort an array uses linear search to identify the position where an element is to be inserted into the already sorted part of the array. If, instead, we use binary search to identify the position, the worst case running time will 1) 2) 3) become Θ(n log n) 4)	become Θ(n)",,remain Θ(n 2 ),,become Θ(n (log n) 2 ),,become Θ(n log n),,become Θ(n),,A,MCQ,,
79,"In a heap with n elements with the smallest element at the root, the 7th smallest element can be found in time",,Θ(n log n),,Θ(n),,Θ(log n),,Θ(1),,D,MCQ,"In order to find out the kth smallest element, we have to first extract 6 elements from heap and then root of the resultant heap will be the kth smallest.Total time complexity = 6 Extract-min operations = 6*log2n = O(log2n) But we can find out kth smallest from heap using a clever approach by extracting elements from heap non-destructively. We will use extra space to create a new min-heap which will contain maximum k elements at any time. Algorithm : Initialize the root element of new-heap with the root of old heap (minimum element) For k-1 times repeat the following : Extract the root of the new min-heap using extract-min and insert the 2 children of the extracted root from the original heap into the new heap. Resulting heap will contain k elements and root of which will be our kth smallest in the original heap. This grows the new heap by one on every removal (remove one, add two), which means it will never hold more than K elements, and so the remove-one-add-two will take O(3*log(K)). After k iterations, it is O(3*k*logk) = O(k*logk). In order to implement this, Nodes in the new heap should store indexes of their corresponding nodes in the original heap, rather than the node values themselves. For 7 elements, it will take 7log7 = O(1) time as new heap will create only 7 elements.",
80,"Consider the set {a, b, c} with binary operators + and × defined as follows : + a b c × a b c a b a c a a b c b a b c b b c a c a c b c c c b For example, a + c = c, c + a = a, c × b = c and b × c = a. Given the following set of equations : (a × x) + (a × y) = c (b × x) + (c × y) = c The number of solution(s) (i.e., pair(s) (x, y)) that satisfy the equations is :",,0,,1,,2,,3,,C,MCQ,"For this question, we will have to consider each case separately and check whether it satisfies both the conditions or not.     (a,a) ⇒ (a*a) + (a*a) = a + a = b ≠ c ⇒ (a,a) is not a solution.  (a,b) ⇒ (a*a) + (a*b) = a + b = a ≠ c ⇒ (a,b) is not a solution.  (a,c) ⇒ (a*a) + (a*c) = a + c = c (b*a)  + (c*c) = b + b = b ≠ c ⇒ (a,c) is not a solution. (b,a) ⇒ (a*b) + (a*a) = b + a = a ≠ c ⇒ (b,a) is not a solution.  (b,b) ⇒ (a*b) + (a*b) = b + b = b ≠ c ⇒ (b,b) is not a solution.  (b,c) ⇒ (a*b) + (a*c) = b + c = c (b*b) + (c*c) = c + b = c ⇒ (b,c) is a solution (c,a) ⇒ (a*c) + (a*a) = c + a = a ≠ c ⇒ (c,a) is not a solution.  (c,b) ⇒ (a*c) + (a*b) = c + b = c (b*c) + (c*b) = a + c = c ⇒ (c,b) is a solution (c,c) ⇒ (a*c) + (a*c) = c + c = b ≠ c ⇒ (c,c) is not a solution.     Thus, we have 2 solutions, (b,c) and (c,b).  Hence, C is the correct choice.",
81,"Let T(n) be the number of different binary search trees on n distinct elements. Then , where x is",https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/81e52d471898cd75-qSRoF60VAKa8cXvxTKozampS3mXFfW.png,n-k+1,,n-k,,n-k-1,,n-k-2,,B,MCQ,"The idea is to make a key root, put (k-1) keys in one subtree and remaining n-k keys in other subtree. A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties − The left sub-tree of a node has a key less than or equal to its parent node's key. The right sub-tree of a node has a key greater than to its parent node's key. Now construction binary search trees from n distinct number- Lets for simplicity consider n distinct numbers as first n natural numbers (starting from 1) If n=1 We have only one possibility, therefore only 1 BST. If n=2 We have 2 possibilities , when smaller number is root and bigger number is the right child or second when the bigger number is root and smaller number as left child. If n=3 We have 5 possibilities. Keeping each number first as root and then arranging the remaining 2 numbers as in case of n=2. If n=4 We have 14 possibilities. Taking each number as root and arranging smaal numbers as left subtree and larger numbers as right subtree. Thus we can conclude that with n distinct numbers, if we take ‘k’ as root then all the numbers smaller than k will left subtree and numbers larger than k will be right subtree where the the right subtree and left subtree will again be constructed recursively like the root. Therefore,","https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/7792a71f101319a6-cUhyZj69KGZC0MMFftPQofGajjPjrs.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/79488f61de6a93a6-Jn5724uuroiI0Pwjv3zbvrabNl10sT.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/284901743680c32c-plCsd60ua2sghQ3LHXRExUMTM4VApT.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Explanation_Images/3cb65d30a67254af-mYhyNCQr3J5gWrXtpXiKW19cMFKocb.png"
82,"Consider the grammar shown below S → i E t S S' | a S' → e S | ε E → b In the predictive parse table. M, of this grammar, the entries M[S', e] and M[S', $] respectively are",,{S' → e S} and {S' → e},,{S' → e S} and {},,{S' → ε} and {S' → ε},,"{S' → e S, S'→ ε} and {S' → ε}",,D,MCQ,"Here representing the parsing table as M[ X , Y ], where X represents rows( Non terminals) and Y represents columns(terminals). Here are the rules to fill the parsing table. For each distinct production rule A->α, of the grammar, we need to apply the given rules: Rule 1 : if A –> α is a production, for each terminal ‘a’ in FIRST(α), add A–>α to M[ A , a ] Rule 2 : if ‘ ε ‘ is in FIRST(α), add A –> α to M [ A , b ] for each ‘b’ in FOLLOW(A).  As Entries have been asked corresponding to Non-Terminal S', hence we only need to consider its productions to get the answer. For S' → eS , according to rule 1, this production rule should be placed at the entry M[ S', FIRST(eS) ], and from the given grammar, FIRST(eS) ={e}, hence S'->eS is placed in the parsing table at entry M[S' , e]. Similarly, For S'->ε , as FIRST(ε) = {ε}, hence rule 2 should be applied, therefore, this production rule should be placed in the parsing table at entry M[S',FOLLOW(S')], and FOLLOW(S') = FOLLOW(S) = { e, $ }, hence R->ε is placed at entry M[ S', e ] and M[ S' , $ ]. Therefore Answer is option D.",
83,Consider the grammar shown below. S → C C C → c C | d The grammar is,,LL(1),,SLR(1) but not LL(1),,LALR(1) but not SLR(1),,LR(1) but not LALR(1),,A,MCQ,"Since there is no conflict, the grammar is LL(1).  We can construct a predictive parse table with no conflicts.   This grammar also  LR(0), SLR(1), CLR(1) and LALR(1).",
84,"Consider the translation scheme shown below S → T R R → + T {print ('+');} R | ε T → num {print (num.val);} Here num is a token that represents an integer and num.val represents the corresponding integer value. For an input string '9 + 5 + 2', this translation scheme will print",,9 + 5 + 2,,9 5 + 2 +,,9 5 2 + +,,+ + 9 5 2,,B,MCQ,"Let us make the parse tree for 9+5+2 in top down manner, left first derivation. Steps: 1) Exapnd S->TR 2) apply T->Num... 3) apply R -> +T... 4) appy T->Num... 5) apply R-> +T.. 6) apply T-> Num.. 7) apply R-> epsilon After printing through the print statement in the parse tree formed you will get the answer as 95+2+",
85,"Consider the syntax directed definition shown below. S → id : = E  {gen (id.place = E.place;);} E → E1 + E2   {t = newtemp ( ); gen (t = El.place + E2.place;); E.place = t} E → id     {E.place = id.place;} Here, gen is a function that generates the output code, and newtemp is a function that returns the name of a new temporary variable on every call. Assume that ti's are the temporary variable names generated by newtemp. For the statement 'X: = Y + Z', the 3-address code sequence generated by this definition is",,X = Y + Z,,t1 = Y + Z; X =  t1,,t1 =Y; t2 = t1 + Z; X = t2,,t1 = Y; t2 = Z; t3 = t1 + t2; X = t3,,B,MCQ,It must be B. The production E --> E + E is used only one time and hence only one temporary variable is generated.,
86,"In a bottom-up evaluation of a syntax directed definition, inherited attributes can",,always be evaluated,,be evaluated only if the definition is L-­attributed,,be evaluated only if the definition has synthesized attributes,,never be evaluated,,B,MCQ,A Syntax Directed Definition (SDD) is called S Attributed if it has only synthesized attributes. L-Attributed Definitions contain both synthesized and inherited attributes but do not need to build a dependency graph to evaluate them.,
87,Assume that the SLR parser for a grammar G has n1 states and the LALR parser for G has n2 states. The relationship between n1 and n2 is:,,n1 is necessarily less than n2,,n1 is necessarily equal to n2,,n1 is necessarily greater than n2,,none of these,,B,MCQ,,
88,Which of the following suffices to convert an arbitrary CFG to an LL(1) grammar?,,Removing left recursion alone,,Factoring the grammar alone,,Removing left recursion and factoring the grammar,,None of these,,D,MCQ,Removing left recursion and factoring the grammar do not suffice to convert an arbitrary CFG to LL(1) grammar.,
89,"Consider the following 2-3-4 tree (i.e., B-tree with a minimum degree of two) in which each data item is a letter. The usual alphabetical ordering of letters is used in constructing the tree. What is the result of inserting G in the above tree ? A) B) C) D) None of the above","https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/ff291f1b72575153-OiWBGQuXCelidgOiaOBH2E8EVdvFud.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/8b8cf36fa1600a23-hEA3JmXxs7WLNgXk12Qi7WmIpGthvO.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/2f4a2c3383419e47-PN3xDDRyFiveenGKd3DqMr6GEhnYMR.png, https://rkokdq5fgqqf84hb.public.blob.vercel-storage.com/gate-cs/2003/Question_Images/e4957ae29838328b-Wnp6mKJgA2NqiMh68eSTYnmmPeMKvF.png",A,,B,,C,,D,,B,MCQ,"Since the given B tree is 2-3-4 tree, there can be at-most 4 children or 3 keys. In B Tree insertion , we start from root and traverse till the leaf node where key is to be inserted.  While traversing, if we find a a node which full, we split it.  When we insert G, we find root itself is full, so we split it.  When we come down to leftmost leaf, we find that the leaf is also full, so we split the leaf also.",
90,"Consider the following system of linear equations [Tex]\begin{bmatrix}
2 & 1 & -4 \\
4 & 3 & -12 \\
1 & 2 & -8
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
z
\end{bmatrix}
=
\begin{bmatrix}
\alpha \\
5 \\
7
\end{bmatrix}[/Tex] Notice that the second and the third columns of the coefficient matrix are linearly dependent. For how many values of α does this system of equations have infinitely many solutions?",,0,,1,,2,,infinitely many,,B,MCQ,,
